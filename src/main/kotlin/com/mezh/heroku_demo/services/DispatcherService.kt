package com.mezh.heroku_demo.servicesimport com.mezh.heroku_demo.dto.Commandimport com.mezh.heroku_demo.entity.MessageDtoimport com.mezh.heroku_demo.entity.StateTypeimport com.mezh.heroku_demo.entity.UserEntityimport com.mezh.heroku_demo.entity.UserStateimport com.mezh.heroku_demo.handler.CommandHadlerimport com.mezh.heroku_demo.handler.dto.CommandContextimport com.mezh.heroku_demo.repository.MessageRepositoryimport org.springframework.stereotype.Serviceimport org.telegram.telegrambots.meta.api.methods.send.SendMessageimport org.telegram.telegrambots.meta.api.objects.CallbackQueryimport org.telegram.telegrambots.meta.api.objects.Message@Serviceclass DispatcherService(        private val messageRepository: MessageRepository,        private val commandHandlers: List<CommandHadler>,        private val userService: UserService) {    fun saveMessage(message: Message?) {        messageRepository.save(                MessageDto(                        id = message?.messageId?.toInt().toString(),                        message = message?.text,                        userId = getUserId(message),                        dateTime = message?.date?.toInt()                )        )    }    fun findLastMessage(): String? {        val messageList = messageRepository.findAll()        if (messageList.isNotEmpty()) {            return messageList.last().message        }        return "not found last message"    }    fun getUserId(message: Message?): Int? {        return message?.from?.id    }    fun createResponse(message: Message?): SendMessage {        if (message == null) return SendMessage()        this.saveMessage(message)        val messageText = message.text        val user = createUserIfEmpty(message.from.id)        val state = user.currentState        if (state == null) {            return getHandlerByStateType(StateType.MAIN_MENU).handle(CommandContext(message, user))        }        val command = handleInputForMainMenu(messageText) ?: Command.valueOf(state.commandName)        return getHandler(command)                .handle(CommandContext(message, user))    }    fun handleInputForMainMenu(messageText: String?): Command? {        if (messageText == null) return null        return when {            checkCommand(Command.ADD_EXERCISES, messageText) -> Command.ADD_EXERCISES            checkCommand(Command.STATISTIC, messageText) -> Command.STATISTIC            checkCommand(Command.CANCEL, messageText) -> Command.CANCEL            else -> null        }    }    fun handle(state: StateType, context: CommandContext): SendMessage {        return getHandlerByStateType(state).handle(context)    }    fun createResponse(callback: CallbackQuery?): SendMessage {        if (callback == null) return SendMessage()        val user = createUserIfEmpty(callback.from.id)        val state = user.currentState        val message = callback.message        val command = findCommand(message.text, state)        return getHandler(command)                .handle(createContext(message, user, callback))    }    fun checkCommand(command: Command, msg: String?): Boolean {        if (msg == null) return false        return msg.contains(command.desc, true) || msg.contains(command.menuName, true)    }    fun createContext(message: Message, user: UserEntity, callback: CallbackQuery?) : CommandContext {        val commandContext = CommandContext(message, user)        commandContext.callbackQuery = callback        return commandContext    }    fun checkState(state: UserState?, command: Command): Boolean {        if (state != null) {            return state.commandName == command.name        }        return false    }    fun findCommand(messageText: String, userState: UserState?) : Command {        var command: Command?        command = handleInputForMainMenu(messageText)        if(command == null && userState != null)            command = Command.valueOf(userState.commandName)        else            command = Command.MENU        return command    }    fun createUserIfEmpty(userId: Int): UserEntity {        val userOpt = userService.findUserById(userId)        if (userOpt.isEmpty) {            val newUser = buildUserEntity(userId.toString())            return userService.save(newUser)        }        return userOpt.get()    }    private fun buildUserEntity(id: String): UserEntity {        return UserEntity(                userId = id,                exercisesList = null,                currentState = null        )    }    fun replyLastMessage(message: Message?): SendMessage {//        val sendMessage = SendMessage()//        sendMessage.text = this.findLastMessage()//        sendMessage.chatId = message?.chatId.toString()//        return sendMessage        return SendMessage()    }    fun getHandler(command: Command): CommandHadler {        return commandHandlers                .first { handler -> handler.getType() == command }    }    fun getHandlerByStateType(state: StateType): CommandHadler {        return commandHandlers                .first { handler -> handler.getStateType() == state }    }}